### 1-1. Big-O, Big-Theta, Big-Omega에 대해 설명해주세요


Big-O : 알고리즘 최악의 실행 시간을 표기한다. 가장 많이 사용하는 표기법이다.
Big-Theta : 알고리즘 평균 실행 시간을 표기한다.
Big-Ω : 알고리즘 최상의 실행 시간을 표기한다.

```
Big-O notation은 일반적인 함수의 점근적 상항을 얘기하는 것으로, 여러 개일 수 있다.
시간 복잡도를 빅오 노테이션으로 표현하는 건 알고리즘의 최악의 연산 횟수를 빅오 노테이션으로 표현하는 것이고, 
이 경우에는 가능하면 가장 작은 함수로 써주는게 좋은 것
```
```
f(n) = n^2+4n+7 라는 고정된 함수에 대해
f(n)의 시간복잡도는 O(N^2)이면서 O(N^3), O(N^4)이기도 하다
그 중에서도 Big-O notation은 "상한"을 정해주는 것으로 얘보다는 빠를 거야! 는 느낌
```

Big-Theta : 코딩테스트에서 다루지 않는 이유 </br>
대부분의 강의에서 다루는 "코딩테스트 이하 난이도의 알고리즘"에 대해서는 빅-세타를 어렵지 않게 구할 수 있다
다만, 대회에서 일부 등장하는 고난이도 문제, 논문에 등장하는 알고리즘들의 경우 '복잡도가 빅-세타로 얼마이다' 같은 깔끔한 해를 구하지 못하고, 그래도 무엇보다 크지는 않다의 서술만
가능한 경우도 있다.

### 1-2. 다른 것을 사용하지 않고, Big-O를 사용하는 이유가 있을까요?

알고리즘의 최소한 보장되는 성능을 표기하기 때문에 가장 일반적으로 사용한다.

### 1-3. O(1)은 O(N^2) 보다 무조건적으로 빠른가요? 
* 그렇다고 볼 수 있다.
```
append() 메서드와 pop() 메서드의 시간복잡도는 O(1)
```

* 입력 데이터의 크기에 상관없이 언제나 일정한 시간이 걸리는 알고리즘을 나타낸다. 데이터가 얼마나 증가하든 성능에 영향을 거의 미치지 않는다.
  O(n^2)
* 데이터가 많아질수록 처리시간이 급수적으로 늘어나는 알고리즘입니다. 예를 들어 데이터가 10배가 되면, 처리 시간은 최대 100배가 된다. 이중 루프(n² matrix)가 대표적이며 단, m이 n보다 작을 때는 반드시 O(nm)로 표시하는 것이 바람직하다.


[참고문헌](https://sohyeonnn.tistory.com/20)
